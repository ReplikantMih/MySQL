-- Денормализация

-- Задание на денормализацию
-- Разобраться как построен и работает следующий запрос:

SELECT SUM(count) as overall FROM (
	SELECT 	
		CONCAT(u.firstname, ' ', u.lastname) as user, 
		count(l.id) as count, 
		TIMESTAMPDIFF(YEAR, p.birthday, NOW()) AS age
			FROM users AS u
		INNER JOIN profiles AS p
			ON p.user_id = u.id
		LEFT JOIN media as m
			ON m.user_id = u.id
		LEFT JOIN messages as t
			ON t.from_user_id = u.id
		LEFT JOIN
			likes AS l
				ON l.item_id = u.id AND l.like_type_id = 2
				OR l.item_id = m.id AND l.like_type_id = 1
				OR l.item_id = t.id AND l.like_type_id = 3
		GROUP BY u.id
		ORDER BY p.birthday DESC
	LIMIT 10) AS likes;
	
-- Правильно-ли он построен?
-- Какие изменения, включая денормализацию, можно внести в структуру БД
-- чтобы существенно повысить скорость работы этого запроса?



-- РЕШЕНИЕ:

-- Насколько я понимаю, автор запроса ожидает, что он будет считать в разрезе пользователей количество лайков, набранных сущностями,
-- созданными 10 самыми молодыми пользователями.

-- Но насколько я понимаю, запрос делает что-то другое. Во вложенном запросе делается SELECT из сджойненных нескольких таблиц.
-- Но - и думаю, это поведение не ожидаем автором - происходит следующее: когда джойнятся users и profiles - все норм,
-- когда джойним дальше кол-во строк для каждого юзера будет равно кол-ву созданных им media - ок, допустим. Далее джойним
-- к этому всему messages, но тут идет необосонованное наращивание кол-ва строк, если у пользователя, допустим, было 100 медиа
-- и 100 сообщений, то после прохождения этапа джойна сообщений, на этого пользователя будет 100 строк, если продолжить в таком
-- же ключе ещё хотя бы пару итераций - система такое просто даже не вытянет, наверно, не говоря уже о скорости. Ну, собственно,
-- когда мы джойним к этому likes, мы в таком же ключе и продолжаем действовать.
-- 
-- Ну, допустим. Это будет работать медленно, но, допустим работать. Идем далее: группируем по юзера, оставляем 10 самых молодых -
-- тут все, вроде, норм. Далее чтобы, предположительно, посчитать кол-во лайков сущностей данного пользователя добавляется вычисляемый
-- столбец count(l.id) as count, но в таком виде фукнция посчитает общее кол-во строк в разрезе юзеров на основе таблицы, кол-во строк
-- в которой не репрезентативно - оно не отражает никакого физического смысла. Если уж считать, то COUNT(DISTINCT l.id) - при этом
-- запрос будет делать то, что от него ожидают, но с существенными избыточными действиями, замедляющими выполнение запроса.
-- 
-- Предложения по улучшению производительности запроса:
-- 1. Без внесения изменений в БД:
-- 		Думаю, быстрее будет работать если взять брать конкретный like_type, джойнить к нему юзеров, сделать так отдельно для разных 
-- 		like_type и объединить через UNION ALL. Далее группируем по юзерам, вычисляя в т.ч. возраст, кол-во лайков, оставляя нужных пользователей.
-- 2. С внесением изменений в БД:
-- 		* Вычислять эти значения с определенной периодичностью и хранить вычисленные значения в таблице profiles, в этом случае запрос будет 
-- 		работать только с таблицей profiles - простой SELECT. В этом случае два компромиссных момента: - денормализация, значения будут
-- 		актуализироваться только с определенной периодичностью, а не в момент запроса.
-- 		* В текущем варианте мы тратим дополнительное время чтобы узнать чей item лайкнут по данному лайку. Если бы таблица лайков хранила не
-- 		только то, кто лайнул, но и то, чей item, то запрос бы выполнялся быстрее, при этом идет дублирование, т.е. нативно принадлежность
-- 		айтема логично хранить в таблие/таблицах где описаны айтемы, если мы эту информацию храним и в лайках - идет дублирование, но это
-- 		ускорит запрос - и в текущем виде и в виде запроса описанного в предложении "без внесения изменения в БД". Соответственно при инсерте
-- 		или апдейте лайка каждый раз надо подтягивать информацию о владельце айтема и прописывать его и в таблицу лайков - т.е. поддерживать 
-- 		целостность ненормализованной структуры.





USE vk;
DESC likes;

CREATE TABLE A (a INT, b INT);
CREATE TABLE B (a INT, b INT);
EXPLAIN INSERT INTO A VALUES (1, 3);
INSERT INTO B VALUES (1, 5), (1, 7);
EXPLAIN SELECT * FROM A WHERE a=1 AND b=7;
SELECT * FROM B;

SELECT COUNT(A.b) FROM A LEFT JOIN B ON A.a = B.a GROUP BY A.a ; 

